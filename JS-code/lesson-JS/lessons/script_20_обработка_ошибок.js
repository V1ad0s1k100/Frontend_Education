console.log('Начало кода...')

const userData = undefined

try {
  const names = undefined

  // Пытаемся перебрать элементы массива names с помощью forEach
  // Так как names равно undefined, это вызовет ошибку, потому что у undefined нет метода forEach
  names.forEach((name) => {
    console.log('Имя: ', name)
  })

  // Если бы не было ошибки, это сообщение было бы выведено
  console.log('Это сообщение не выведется')
} catch (error) {
  // Если в блоке try произошла ошибка, она будет перехвачена здесь
  // error - это объект ошибки, содержащий информацию об ошибке
  console.log('Возникла ошибка: ', error)
}

console.log('Конец кода...')

console.log('\nСледующая конструкция с некоректным кодом')

// В случае, если просто ввести некоретный код, то конструкция trycatch срабатывать не будет (ошибки парсинга, ошибки, которые JS обнаруживает еще до вывода программы в консоль)

// try {
//   // Этот код содержит синтаксическую ошибку (345console.log), поэтому он не будет выполнен
//   // Ошибки парсинга не могут быть перехвачены try...catch, потому что они происходят до выполнения кода
//   345console.log('Привет мир!')
// } catch (error) {
//   console.log(error)
// }

// Ошибки с асинхронным кодом конструкция не отлавливает

// try {
//   // setTimeout выполняет код асинхронно, поэтому ошибки внутри setTimeout не будут перехвачены внешним блоком try...catch
//   setTimeout(() => {
//     const names = undefined

//     names.forEach((name) => {
//       console.log('Имя: ', name)
//     })
//   }, 3000)
// } catch (error) {
//   console.log(error)
// }

// Для решения данной проблемы стоит отлавливать ошибки внутри конструкций с асинхронностью кода

// Чтобы перехватить ошибки в асинхронном коде, нужно поместить блок try...catch внутрь асинхронной функции
setTimeout(() => {
  try {
    const names = undefined

    names.forEach((name) => {
      console.log('Имя: ', name)
    })
  } catch (error) {
    // error - это не просто строка ошибки это объект, который содержит 3 свойства
    console.log('\nСледующая конструкция с асинхронным кодом')
    // Выводим различные свойства объекта ошибки
    console.log('\n', error.name) // Имя ошибки (например, TypeError)
    console.log('\n', error.message) // Сообщение об ошибке
    console.log('\n', error.stack) // Трассировка стека вызовов, приведших к ошибке
  }
}, 3000)

console.log('\nСледующая конструкция с JSON форматом')

try {
  /**
   *Код с ошибкой
   *(висячая запятая в конце значения свойства *"age")
   */
  // userJSON содержит JSON строку с ошибкой (висячая запятая после "age": "17")
  const userJSON = `{
    "name": "Владислав",
    "age": "17",
   }`

  // JSON.parse попытается преобразовать строку JSON в объект JavaScript
  // Из-за ошибки в JSON строке, JSON.parse вызовет ошибку
  console.log(JSON.parse(userJSON))
} catch (error) {
  // Ошибка, возникшая при парсинге JSON, будет перехвачена здесь
  console.log('\nВозникла ошибка: ', error)
}

// Конструкция обрабатывает только те ошибки, которые JS воспринимает за ошибки

try {
  // JSON строка без ошибок
  const userJSON = JSON.parse(`{
    "name": "Владислав"
   }`)

  // Для того чтобы обрабатывать логические ошибки при выводе нужно пользоваться своими проверками

  // Проверяем, есть ли у объекта userJSON свойство age
  if (!userJSON.age) {
    // Для выброса своей (кастомной) ошибки чаще используют специальный класс Error, который позволяет вывести свойства name, message и stack присваивая им значения сообщения, переданного этому классу
    // Существуют также другие классы вывода ошибок, которые позовляют делать ошибки более конкретизированными
    // Если свойства age нет, выбрасываем свою ошибку
    throw new Error('Имя не заполнено!')
  }
} catch (error) {
  // Ошибка, выброшенная нами, будет перехвачена здесь
  console.log('\nВозникла ошибка: ', error)
}

try {
  console.log('\nКод в блоке try отработал корректно')
} catch (error) {
  console.log('Возникла ошибка: ', error)
} finally {
  // Блок finally выполняется всегда, независимо от того, была ли ошибка в блоке try или нет
  console.log('Блок кода (finally) выполняется в любом случае')
}
